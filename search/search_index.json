{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Layered Models</p> <p>Once systems become very complex, they can become unmanageable. I don\u2019t know if anyone has a rule of thumb, but if not, I\u2019ll claim this one (JOR\u2019s first law of complexity!). </p> <p>When you double the number of components in a system, you square its complexity.</p> <p>So, there we have it, a completely new hypothesis (arbitrary and unproven) in the lexicon of Science! </p> <p>Is it true\u2026\u2026 I have no idea! </p> <p>Does it roughly describe what we experience\u2026yes! </p> <p>For much of the past 60 years we have struggled with the notion of complexity. We really started understanding the magnitude of the problem as very complex projects occurred; the space race in the 1960s resulted in the development of many new forms of logistical planning and tracking. </p> <p>For a while, we found ways of mitigating the problems of complexity. We had seen spaghetti code; programs which were so complex and unwieldy as to be unmaintainable. We addressed those problems with structure, functions and later object orientation and code reuse. In early UNIX development, the folks had a great ideology; each tool does one and one job only. Make each tool as simple as possible. This was a great way of mitigating some of the early issues. </p> <p>In telecommunications, we often take the same approach. Suppose we look at the physical way of connecting things. We could use wires of many different types, fiber optics, radio, smoke signals, carrier pigeons etc. Does an application like a web browser need to know how data packets are being carried? </p> <p>Probably not.</p> <p>The easy way to approach these things is to compartmentalize all the things we want to be able to do into layers and let each layer be independent of the others. If we need to change a layer, we just need to worry about its inter-connectedness to other layers, not what is in the layer itself. So an application which can work on a modem, can work on Ethernet or on a radio network.</p> <p>In the early days of development of this layered approach to communications there were many contributors, none of whom agreed. The result was a compromise which didn\u2019t really suit anybody, but that we still use to this day to describe the layers and inter-relations in a communications model. </p> <p>In the next few pages, we will look at how layered models allow us to describe how nodes (computer, printers, etc.) connected to networks and interconnect with each other. In each case we will look at the most typical protocols you are likely to be exposed to. Keep in mind that there are many other alternatives out there! I will examine the ISO/OSI model (they  really called it that!). </p> <p>In the ISO/OS model, if you concatenate the first two, and the top three layers of this model, you have the TCP/IP Model. Do a little background reading on this. </p>"},{"location":"a/","title":"Layer 1","text":"<p>The Physical Layer</p> <p>The first layer in any data communications system will be the physical layer. This is where we describe the wires or cables of radio waves, the electrical or optical properties, signal levels and encoding of the raw bits. </p> <p>For example, the ubiquitous structured cabling which we use for computing is called CAT5e or CAT6 and the most common protocol is Ethernet. Signals on this cable have; </p> <ul> <li>An electrical level for symbols; Ethernet has five levels, rather than just ones and zeros.</li> <li>A bit rate of 250Mbps per pair over four pairs</li> <li>An encoding scheme to increase the amount of information per symbol</li> <li>An error correction scheme </li> </ul> <p>We could also look at the standards for transmitting Ethernet over </p> <ul> <li>Fibre optics; the physical parameters would be different (light frequency, encoding etc.), but we would still be transmitting Ethernet. </li> <li>Radio; the physical parameters would be wavelength, channel width, signalling, but we would still be transmitting Ethernet. </li> </ul> <p>At layer 1 we find the physical connections and properties to allow for data communications. </p> <p>When someone talks about a layer 1 problem, they mean a wire is broken, there is radio noise, or fibre optic cables need cleaning. The devices at layer 1 are cables, transceivers, signal repeaters. We can connect computers together at layer 1 by running a cable between them of using a multi-port repeater called a hub. </p> <p>In your own time, read about ISO11801, it\u2019s the standard that defines hierarchical wiring of networks for the Enterprise. It might also be worthwhile checking TIA-942 which describes data centre wiring (amongst other things) in the US. Or perhaps the newer European EN50600 series of standards for data centres.</p>"},{"location":"b/","title":"Layer 2","text":"<p>The Data Link Layer</p> <p>Layer 2 provides for the standards that let us communicate between two devices which are directly connected to each other or are on the same network as each other. There have been many standards at layer 2, such as token bus and token ring, ATM, FDDI (feel free to look these up). However, Ethernet is the most common modern standard for communications between two nodes on the same network.</p> Fig 1. An Ethernet Frame. <p>We will look in more detail at the Ethernet frame in later exercises. However, every network card has a unique 48-bit Media Access Control (MAC) address, unique in the whole world and standardized;  a physical address.</p> <p>The sending node sends out a frame with a destination address (so the computer the frame is intended for knows that the frame is for it) and its own address, a data payload. The standard includes for things like knowing when the network is busy or free, identifying when frames of data have got mangled or when two devices try to communicate at the same time and talk over each other (called a collision).</p> <p>To connect computers at layer 2, we need active devices which understand MAC addresses and can keep a track of them. A device like this is called a bridge. The most common device in a modern enterprise or data centre is the multi-port bridge, known as a switch.  Where we need to secure a network segment at layer 2, we can use a transparent or layer 2 firewall.</p>"},{"location":"c/","title":"Layer 3","text":"<p>The Inter-Network Layer</p> <p>Layer 2 allows two devices on the same network to talk to each other using addresses which are unique to every network card. This works because it\u2019s easy to keep track of the few dozen (or few hundred) devices that are on the same network. </p> <p>That makes layer three easy to explain. Layer 3 allows devices on different networks to talk to each other and the most common protocol we use for this is Internet Protocol (IP). We can\u2019t locate all these devices based on their unique addresses, or we would have to know the network path to every individual device in the world AND track then as they move around. Layer 3 works by assigning a block of addresses to a network and then telling the whole world where to find that block of addresses. These blocks can be big enough to accommodate millions of nodes, or as small as 256 nodes.</p> <p>When a node joins a network, it keeps its layer 2 (Ethernet) address, but it is also given a layer 3 (IP) logical address. We now construct a layer 3 packet for sending to another network. It has IP addresses which are globally significant and unique. Every network in the world knows how to find every other network, so once we know what network a node is part of, we can route packets to that network and hence to that node. </p> <p>We encapsulate the IP packet as the data field in the Ethernet frame and we use the Ethernet frame to transport the packet around the local network. To get to another network, the Ethernet frame has to terminate in a router, a device which routes packets at layer 3. The router strips the Ethernet frame off and forwards the IP packet to the next nearest router to its destination. The links between routers may be Ethernet or some other layer 2 protocol. We don\u2019t care; layer 2 is how the devices communicate with each other locally only. The layer 3 packet is passed from router to router until it gets to its destination network.</p> Fig 2. An IPv4 packet encapsulated. <p>To secure a network subnet at layer 3, we use a router with Access Control Lists (ACLs) or we can use a firewall.</p>"},{"location":"d/","title":"Layer 4","text":"<p>The Transport Layer</p> <p>So now we have Layer 3, a way of communicating from a node on one network to any other node on any other network. The next thing we must worry about is the quality of that communication.  - How do I know if a packet of data I send is received?  - How do I tune my communications to the vagaries of the many links from end-to-end? </p> <p>These things we do at layer 4.</p>"},{"location":"d/#transmission-control-protocol-tcp","title":"Transmission Control Protocol (TCP)","text":"<p>The first trick we have is to ensure that if a packet is lost, we can identify it and ask for a resend of exactly that packet. Or if packets arrive out of sequence that we can rearrange the data into the correct order. We do this by numbering each packet we send with a unique 32-bit sequence number. Each packet sent is acknowledged by a return packet which also has a unique 32-bit number. Rather than sending packets into a black hole, the effect of this is to establish host to host communications. </p> <p>TCP also includes a flow control mechanism. We could send just one packet and wait for an acknowledgement, but this would be very slow. A better way to send packets is to use a sliding window. The sender will send a fixed number of packets before getting an acknowledgement. If everything works, the sender will now increase the number of packets it will send without waiting for an acknowledgement. Eventually, packets will be lost and the sender will reduce the number of packets in transit again, a sliding window. There are many other features in the TCP stack, some of the features are arguably layer 5. Do some background reading on it.</p> <p>TCP is encapsulated in the IP packet.</p> Fig 3. TCP Encapsulation."},{"location":"d/#user-datagram-protocol-udp","title":"User Datagram Protocol (UDP)","text":"<p>Many network applications do not require reliable host to host communications. For example, if we are streaming audio or video, there is no point adding back a missing frame two seconds after it should have been in the audio stream. We also have multi-cast traffic; traffic which egresses from one node but is received by many. UDP provides an unreliable service and datagrams may arrive out of order, appear duplicated, or go missing without notice.</p> <p>UDP is encapsulated in the IP packet.</p> Fig 4. UDP Encapsulation."},{"location":"d/#ports","title":"Ports","text":"<p>We may establish communications between two hosts for a purpose; for example, a web server and client. </p> <p>But how would we allow another application to run between the two hosts at the same time?</p> <p>How we would distinguish between packets for each application? </p> <p>We do this by using port numbers. There is a 16-bit field in the headers of the UDP and TCP protocol which allow us to distinguish one application from another and multiplex multiple protocols to the same IP address. For example, </p> <ul> <li>All unencrypted web traffic will arrive with a destination port of 80</li> <li>All encrypted web traffic will arrive with a destination port of 443</li> <li>All Telnet traffic will arrive with a port number of 23, etc.</li> </ul>"},{"location":"d/#security","title":"Security","text":"<p>We can keep a track of the applications which run across our networks based on port numbers, but this is very over simplistic, as malware can use a well-known port and be mistaken for a genuine application. Standard firewalls do this.</p> <p>On a LAN, we can use protocols like IPSEC to secure file sharing, in my experience, this is rarely done. </p> <p>In the wide are, we use VPNs to secure sessions, based on IPSEC or Secure Sockets Layer (SSL), which these days is Transport Layer Security (TLS).</p>"},{"location":"e/","title":"Layer 5, 6, 7","text":"<p>Session, Presentation and Application Layers</p> <p>The top layers of the model are less easy for us to map to real purposes in data communication and tend to get aggregated together by us networking people. </p> <p>In theory layer 5 maintains session information between two hosts (but didn\u2019t we do that with TCP at layer 4?). </p> <p>Layer 6 is about presenting data to the final application, which lives at layer 7. </p> <p>The reality, some of our protocols bridge layers, break layers, etc. It is after all, only a model.</p> Fig 5. Layer summary, my version. <p>The ultimate way to secure hosts is to have a firewall which is application aware. We call these layer 7 firewalls or proxies and we can use them to monitor and control traffic even where it uses anomalous ports. </p> <p>We can take a similar approach to securing services; we can use a Web Application Firewall (WAF), where the traffic to and from a server is understood at the application level.</p>"}]}